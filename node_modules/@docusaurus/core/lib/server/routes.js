"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@docusaurus/utils");
const lodash_1 = __importDefault(require("lodash"));
const querystring_1 = require("querystring");
function isModule(value) {
    if (lodash_1.default.isString(value)) {
        return true;
    }
    if (lodash_1.default.isPlainObject(value) &&
        lodash_1.default.has(value, '__import') &&
        lodash_1.default.has(value, 'path')) {
        return true;
    }
    return false;
}
function getModulePath(target) {
    if (typeof target === 'string') {
        return target;
    }
    const queryStr = target.query ? `?${querystring_1.stringify(target.query)}` : '';
    return `${target.path}${queryStr}`;
}
async function loadRoutes(pluginsRouteConfigs, baseUrl) {
    const routesImports = [
        `import React from 'react';`,
        `import ComponentCreator from '@docusaurus/ComponentCreator';`,
    ];
    const registry = {};
    const routesPaths = [utils_1.normalizeUrl([baseUrl, '404.html'])];
    const routesChunkNames = {};
    // This is the higher level overview of route code generation.
    function generateRouteCode(routeConfig) {
        const { path: routePath, component, modules = {}, routes, exact, } = routeConfig;
        if (!lodash_1.default.isString(routePath) || !component) {
            throw new Error(`Invalid routeConfig (Path must be a string and component is required) \n${JSON.stringify(routeConfig)}`);
        }
        if (!routes) {
            routesPaths.push(routePath);
        }
        function genRouteChunkNames(value, prefix, name) {
            if (!value) {
                return null;
            }
            if (lodash_1.default.isArray(value)) {
                return value.map((val, index) => genRouteChunkNames(val, `${index}`, name));
            }
            if (isModule(value)) {
                const modulePath = getModulePath(value);
                const chunkName = utils_1.genChunkName(modulePath, prefix, name);
                // We need to JSON.stringify so that if its on windows, backslashes are escaped.
                const loader = `() => import(/* webpackChunkName: '${chunkName}' */ ${JSON.stringify(modulePath)})`;
                registry[chunkName] = {
                    loader,
                    modulePath,
                };
                return chunkName;
            }
            const newValue = {};
            Object.keys(value).forEach(key => {
                newValue[key] = genRouteChunkNames(value[key], key, name);
            });
            return newValue;
        }
        routesChunkNames[routePath] = lodash_1.default.assign(routesChunkNames[routePath], genRouteChunkNames({ component }, 'component', component), genRouteChunkNames(modules, 'module', routePath));
        const routesStr = routes
            ? `routes: [${routes.map(generateRouteCode).join(',')}],`
            : '';
        const exactStr = exact ? `exact: true,` : '';
        return `
{
  path: '${routePath}',
  component: ComponentCreator('${routePath}'),
  ${exactStr}
  ${routesStr}
}`;
    }
    const routes = pluginsRouteConfigs.map(generateRouteCode);
    const notFoundRoute = `
  {
    path: '*',
    component: ComponentCreator('*')
  }`;
    const routesConfig = `
${routesImports.join('\n')}

export default [
  ${routes.join(',')},
  ${notFoundRoute}
];\n`;
    return {
        registry,
        routesConfig,
        routesChunkNames,
        routesPaths,
    };
}
exports.loadRoutes = loadRoutes;
