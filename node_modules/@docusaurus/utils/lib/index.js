"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const crypto_1 = require("crypto");
const lodash_1 = __importDefault(require("lodash"));
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const fileHash = new Map();
async function generate(generatedFilesDir, file, content, skipCache = process.env.NODE_ENV === 'production') {
    const filepath = path_1.default.join(generatedFilesDir, file);
    if (skipCache) {
        await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
        await fs_extra_1.default.writeFile(filepath, content);
        return;
    }
    let lastHash = fileHash.get(filepath);
    // If file already exists but its not in runtime cache yet,
    // we try to calculate the content hash and then compare
    // This is to avoid unnecessary overwriting and we can reuse old file.
    if (!lastHash && fs_extra_1.default.existsSync(filepath)) {
        const lastContent = await fs_extra_1.default.readFile(filepath, 'utf8');
        lastHash = crypto_1.createHash('md5')
            .update(lastContent)
            .digest('hex');
        fileHash.set(filepath, lastHash);
    }
    const currentHash = crypto_1.createHash('md5')
        .update(content)
        .digest('hex');
    if (lastHash !== currentHash) {
        await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
        await fs_extra_1.default.writeFile(filepath, content);
        fileHash.set(filepath, currentHash);
    }
}
exports.generate = generate;
function objectWithKeySorted(obj) {
    // https://github.com/lodash/lodash/issues/1459#issuecomment-253969771
    return lodash_1.default(obj)
        .toPairs()
        .sortBy(0)
        .fromPairs()
        .value();
}
exports.objectWithKeySorted = objectWithKeySorted;
const indexRE = /(^|.*\/)index\.(md|js|jsx|ts|tsx)$/i;
const extRE = /\.(md|js|tsx)$/;
/**
 * Convert filepath to url path.
 * Example: 'index.md' -> '/', 'foo/bar.js' -> '/foo/bar',
 */
function fileToPath(file) {
    if (indexRE.test(file)) {
        return file.replace(indexRE, '/$1');
    }
    return `/${file.replace(extRE, '').replace(/\\/g, '/')}`;
}
exports.fileToPath = fileToPath;
function encodePath(userpath) {
    return userpath
        .split('/')
        .map(item => encodeURIComponent(item))
        .join('/');
}
exports.encodePath = encodePath;
/**
 * Given an input string, convert to kebab-case and append a hash.
 * Avoid str collision.
 */
function docuHash(str) {
    if (str === '/') {
        return 'index';
    }
    const shortHash = crypto_1.createHash('md5')
        .update(str)
        .digest('hex')
        .substr(0, 3);
    return `${lodash_1.default.kebabCase(str)}-${shortHash}`;
}
exports.docuHash = docuHash;
/**
 * Generate unique React Component Name.
 * E.g: /foo-bar -> FooBar096
 */
function genComponentName(pagePath) {
    if (pagePath === '/') {
        return 'index';
    }
    const pageHash = docuHash(pagePath);
    const pascalCase = lodash_1.default.flow(lodash_1.default.camelCase, lodash_1.default.upperFirst);
    return pascalCase(pageHash);
}
exports.genComponentName = genComponentName;
/**
 * Convert Windows backslash paths to posix style paths.
 * E.g: endi\\lie -> endi/lie
 */
function posixPath(str) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(str);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(str); // eslint-disable-line
    if (isExtendedLengthPath || hasNonAscii) {
        return str;
    }
    return str.replace(/\\/g, '/');
}
exports.posixPath = posixPath;
const chunkNameCache = new Map();
/**
 * Generate unique chunk name given a module path.
 */
function genChunkName(modulePath, prefix, preferredName, shortId = process.env.NODE_ENV === 'production') {
    let chunkName = chunkNameCache.get(modulePath);
    if (!chunkName) {
        if (shortId) {
            chunkName = crypto_1.createHash('md5')
                .update(modulePath)
                .digest('hex')
                .substr(0, 8);
        }
        else {
            let str = modulePath;
            if (preferredName) {
                const shortHash = crypto_1.createHash('md5')
                    .update(modulePath)
                    .digest('hex')
                    .substr(0, 3);
                str = `${preferredName}${shortHash}`;
            }
            const name = str === '/' ? 'index' : docuHash(str);
            chunkName = prefix ? `${prefix}---${name}` : name;
        }
        chunkNameCache.set(modulePath, chunkName);
    }
    return chunkName;
}
exports.genChunkName = genChunkName;
function idx(target, keyPaths) {
    return (target &&
        keyPaths &&
        (Array.isArray(keyPaths)
            ? keyPaths.reduce((obj, key) => obj && obj[key], target)
            : target[keyPaths]));
}
exports.idx = idx;
/**
 * Given a filepath and dirpath, get the first directory.
 */
function getSubFolder(file, refDir) {
    const separator = escape_string_regexp_1.default(path_1.default.sep);
    const baseDir = escape_string_regexp_1.default(path_1.default.basename(refDir));
    const regexSubFolder = new RegExp(`${baseDir}${separator}(.*?)${separator}.*`);
    const match = regexSubFolder.exec(file);
    return match && match[1];
}
exports.getSubFolder = getSubFolder;
function parse(fileString) {
    const options = {
        excerpt: (file) => {
            file.excerpt = file.content
                .trim()
                .split('\n', 1)
                .shift();
        },
    };
    const { data: frontMatter, content, excerpt } = gray_matter_1.default(fileString, options);
    return { frontMatter, content, excerpt };
}
exports.parse = parse;
function normalizeUrl(rawUrls) {
    const urls = rawUrls;
    const resultArray = [];
    // If the first part is a plain protocol, we combine it with the next part.
    if (urls[0].match(/^[^/:]+:\/*$/) && urls.length > 1) {
        const first = urls.shift();
        urls[0] = first + urls[0];
    }
    // There must be two or three slashes in the file protocol,
    // two slashes in anything else.
    const replacement = urls[0].match(/^file:\/\/\//) ? '$1:///' : '$1://';
    urls[0] = urls[0].replace(/^([^/:]+):\/*/, replacement);
    // eslint-disable-next-line
    for (let i = 0; i < urls.length; i++) {
        let component = urls[i];
        if (typeof component !== 'string') {
            throw new TypeError(`Url must be a string. Received ${typeof component}`);
        }
        if (component === '') {
            // eslint-disable-next-line
            continue;
        }
        if (i > 0) {
            // Removing the starting slashes for each component but the first.
            component = component.replace(/^[/]+/, '');
        }
        // Removing the ending slashes for each component but the last.
        // For the last component we will combine multiple slashes to a single one.
        component = component.replace(/[/]+$/, i < urls.length - 1 ? '' : '/');
        resultArray.push(component);
    }
    let str = resultArray.join('/');
    // Each input component is now separated by a single slash
    // except the possible first plain protocol part.
    // Remove trailing slash before parameters or hash.
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');
    // Replace ? in parameters with &.
    const parts = str.split('?');
    str = parts.shift() + (parts.length > 0 ? '?' : '') + parts.join('&');
    // Dedupe forward slashes in the entire path, avoiding protocol slashes.
    str = str.replace(/([^:]\/)\/+/g, '$1');
    // Dedupe forward slashes at the beginning of the path.
    str = str.replace(/^\/+/g, '/');
    return str;
}
exports.normalizeUrl = normalizeUrl;
/**
 * Alias filepath relative to site directory, very useful so that we
 * don't expose user's site structure.
 * Example: some/path/to/website/docs/foo.md -> @site/docs/foo.md
 */
function aliasedSitePath(filePath, siteDir) {
    const relativePath = path_1.default.relative(siteDir, filePath);
    // Cannot use path.join() as it resolves '../' and removes
    // the '@site'. Let webpack loader resolve it.
    return `@site/${relativePath}`;
}
exports.aliasedSitePath = aliasedSitePath;
